

---INCLUDE------------------------------------------------------------

	loadstring( exports.core:include('gui.graphics') )()

---GLOBALS------------------------------------------------------------

	windowAnimSpeed = 0.1

	setAnimData('input-blim', 0.2)

	selectedInput = false
	inputFocused = false
	activeList = false
	handleClick = false
	windowOpened = false
	dragDropFlag = false

	blurBackground = true
	isWindowActive = true

	windowModel = {}

	-- whiteTexture = copyTexture(exports.core:getTexture('white'))
	-- closeTexture = copyTexture(exports.core:getTexture('close'))
	-- scrollTexture = copyTexture(exports.core:getTexture('scroll'))
	-- transparentTexture = copyTexture(exports.core:getTexture('transparent'))
	-- roundTexture = copyTexture(exports.core:getTexture('round'))

	whiteTexture = exports.core:getTexture('white')
	closeTexture = exports.core:getTexture('close')
	scrollTexture = exports.core:getTexture('scroll')
	transparentTexture = exports.core:getTexture('transparent')
	roundTexture = exports.core:getTexture('round')


	__basic_Ignore = {}

	openHandlers = {}
	closeHandlers = {}

	-- addEventHandler('onClientResourceStart', resourceRoot, function(resource)
	-- 	whiteTexture = exports.core:getWhiteTexture()
	-- 	closeTexture = exports.core:getCloseTexture()
	-- 	scrollTexture = exports.core:getScrollTexture()
	-- end)

---SOURCE TEXTURE CLASSES------------------------------------------------------------

	textureSourcesQueue = {}

	function createTextureSource(type, path,  ...)

		local texture = sourceTextures[type]( ... )

		local pixels = dxConvertPixels( dxGetTexturePixels(texture), 'png' )

		if fileExists(path) then
			fileDelete(path)
		end

		local file = fileCreate(path)
		fileWrite(file, pixels)
		fileClose(file)

		destroyElement(texture)

		textureSourcesQueue[path] = {type, path, ...}

		return path

	end

	sourceTextures = {

		shadow = function(source, size, alpha)

			local texture = dxCreateTexture(source)
			local mw,mh = dxGetMaterialSize(texture)

			local tw,th = mw + size*2, mh + size*2
			local target = dxCreateRenderTarget(tw,th, true)

			dxSetRenderTarget(target)

				local s_alpha = alpha
				for i = 1, size do
					dxDrawImage(
						tw/2 - mw/2 - i, th/2 - mh/2 - i,
						mw + i*2, mh + i*2,
						texture, 0, 0, 0, tocolor(255,255,255,s_alpha)
					)

					s_alpha = s_alpha - alpha/size

				end

			dxSetRenderTarget()

			destroyElement(texture)

			return target


		end,

		border_round = function(borderRadius)

			local roundTexture = exports.core:getTexture('round')

			local size = borderRadius*2

			local target = dxCreateRenderTarget(borderRadius, borderRadius, true)

			dxSetRenderTarget(target)

				mta_dxDrawImage(
					-1, -1, size+2, size+2, roundTexture
				)

			dxSetRenderTarget()

			return target

		end,

		bordered_rectangle = function(borderRadius, w, h, corners)

			corners = corners or {true, true, true, true}

			borderRadius = math.floor(borderRadius)
			local corner_texture_path = string.format('__corner_%s_px.png', borderRadius)
			local path = createTextureSource('border_round', corner_texture_path, borderRadius)

			borderRadius=borderRadius*2
			w=w*2
			h=h*2

			local corner_texture = dxCreateTexture(path)
			local mw,mh = dxGetMaterialSize(corner_texture)

			local target = dxCreateRenderTarget(w, h, true)

			dxSetRenderTarget(target)

				mta_dxDrawImage(
					0, 0, mw,mh, corners[2] and corner_texture or whiteTexture,
					0, 0, 0, tocolor(255,255,255,255)
				)

				mta_dxDrawImage(
					0, h-mh, mw,mh, corners[1] and corner_texture or whiteTexture,
					-90, 0, 0, tocolor(255,255,255,255)
				)

				mta_dxDrawImage(
					w-mw, 0, mw,mh, corners[3] and corner_texture or whiteTexture,
					90, 0, 0, tocolor(255,255,255,255)
				)

				mta_dxDrawImage(
					w-mw, h-mh, mw,mh, corners[4] and corner_texture or whiteTexture,
					180, 0, 0, tocolor(255,255,255,255)
				)

				mta_dxDrawRectangle(
					mw - 2, 0, w-mw*2 + 4, h + 2,
					tocolor(255,255,255,255)
				)

				mta_dxDrawRectangle(
					0, mh - 2, w + 2, h-mh*2 + 4,
					tocolor(255,255,255,255)
				)

			dxSetRenderTarget()

			destroyElement(corner_texture)

			return target


		end,

		bordered_empty_rectangle = function(borderRadius, borderWidth, w, h)

			borderRadius = math.floor(borderRadius)
			local corner_texture_path = string.format('__corner_%s_px.png', borderRadius)
			local path = createTextureSource('border_round', corner_texture_path, borderRadius)

			borderRadius=borderRadius*2
			w=w*2
			h=h*2

			local corner_texture = dxCreateTexture(path)
			local mw,mh = dxGetMaterialSize(corner_texture)

			local target = dxCreateRenderTarget(w, h, true)

			dxSetRenderTarget(target)

				mta_dxDrawImage(
					0, 0, mw,mh, corner_texture,
					0, 0, 0, tocolor(255,255,255,255)
				)

				mta_dxDrawImage(
					0, h-mh, mw,mh, corner_texture,
					-90, 0, 0, tocolor(255,255,255,255)
				)

				mta_dxDrawImage(
					w-mw, 0, mw,mh, corner_texture,
					90, 0, 0, tocolor(255,255,255,255)
				)
				mta_dxDrawImage(
					w-mw, h-mh, mw,mh, corner_texture,
					180, 0, 0, tocolor(255,255,255,255)
				)

				mta_dxDrawRectangle(
					mw - 2, 0, w-mw*2 + 4, h + 2,
					tocolor(255,255,255,255)
				)

				mta_dxDrawRectangle(
					0, mh - 2, w + 2, h-mh*2 + 4,
					tocolor(255,255,255,255)
				)

			dxSetRenderTarget()


			local target2 = dxCreateRenderTarget(w, h, true)

			dxSetRenderTarget(target2)

				mta_dxDrawImage(
					borderWidth, borderWidth,
					w - borderWidth*2, h - borderWidth*2,
					target,
					0, 0, 0, 
					tocolor(255,255,255,255)
				)

			dxSetRenderTarget()

			local target2_tex = copyTexture(target2)

			local final = cutTextureByMask( target, {
				mask = target2_tex,
				alpha = 1,
				mode = 1,
			} )

			dxSetRenderTarget(target2, true)

				mta_dxDrawImage(
					0, 0, w,h, final
				)

			dxSetRenderTarget()

			destroyElement(corner_texture)
			destroyElement(target)
			destroyElement(target2_tex)

			return target2


		end,

	}

	function refreshWindowSources()

		setTimer(function()

			for path in pairs( textureSourcesQueue ) do

				createTextureSource( unpack( textureSourcesQueue[path] ) )

				if isElement( curDrawingTextures[path] ) then
					destroyElement( curDrawingTextures[path] )
				end

				-- if not clearGuiTextures then
				-- 	curDrawingTextures[path] = getDrawingTexture(path)
				-- else
					curDrawingTextures[path] = nil
				-- end

			end
			
		end, 100, 1)

	end

	addEventHandler('onClientMinimize', root, function()
		isWindowActive = false
	end)

	function onRestore()

		isWindowctive = true
		refreshWindowSources()
		removeEventHandler('onClientRestore', root, onRestore)

	end
	addEventHandler('onClientRestore', root, onRestore)

---DRAW FUNCTIONS------------------------------------------------------------

	drawFunctions = {

		element = function()
		end,

		image = function(element)

			local path = element[6]

			if not isElement(path) then
				createDrawingTexture(path)
			end

			local drawFunc = dxDrawImage
			if element.mtaDraw then
				drawFunc = mta_dxDrawImage
			end

			local color = element.color or {255,255,255,255}
			if isElement(element[6]) or fileExists(element[6]) then

				local x,y,w,h = getElementAbsoluteOffset(element)
				drawFunc(
					x,y,w,h,
					curDrawingTextures[path] or element[6], element.rot or 0, 0, 0,
					tocolor(
						color[1],color[2],color[3],
						color[4]*windowAlpha
					)
				)
			end
		end,

		button = function(element, id)

			local drawFunc1 = dxDrawImage
			local drawFunc2 = dxDrawText
			local hoverFunc = isMouseInPosition
			if element.mtaDraw then
				drawFunc1 = mta_dxDrawImage
				drawFunc2 = mta_dxDrawText
				hoverFunc = mta_isMouseInPosition
			end

			local animData = element.animData

			local x,y,w,h = getElementAbsoluteOffset(element)

			local eColor = element.color or {255,255,255,255}

			local colorHover = element.activeColor


			local color = {unpack(eColor)}

			if not colorHover then
				colorHover = {
					color[1], color[2], color[3], color[4]
				}
				color[1] = color[1] * 0.8
				color[2] = color[2] * 0.8
				color[3] = color[3] * 0.8
			end

			colorHover[4] = eColor[4]


			if element.bg then

				local hr,hg,hb = interpolateBetween(
					color[1], color[2], color[3],
					colorHover[1], colorHover[2], colorHover[3],
					animData, 'Linear'
				)

				drawFunc1(
					x,y,w,h,
					element.bg, element.rot or 0, 0, 0,
					tocolor(
						hr,hg,hb,
						color[4]*windowAlpha
					)
				)
				if element.activeBg then
					drawFunc1(
						x,y,w,h,
						element.activeBg, element.rot or 0, 0, 0,
						tocolor(
							colorHover[1],colorHover[2],colorHover[3],
							colorHover[4]*animData*windowAlpha
						)
					)
				end



			end

			if element.activeFg then
				local r,g,b = unpack( element.activeFgColor or {255,255,255} )
				drawFunc1(
					x,y,w,h,
					element.activeFg, element.rot or 0, 0, 0,
					tocolor(
						r,g,b,
						animData*eColor[4]*windowAlpha
					)
				)
			end

			local textColor = element.textColor or {255,255,255}
			local activeTextColor = element.activeTextColor or textColor

			local tr,tg,tb = interpolateBetween(
				textColor[1], textColor[2], textColor[3],
				activeTextColor[1], activeTextColor[2], activeTextColor[3],
				animData, 'Linear'
			)

			local text = type(element[6]) == 'function' and (element[6])(element) or element[6]

			drawFunc2(text,
				x,y,
				x+w,y+h,
				tocolor(tr,tg,tb,255*windowAlpha* (color[4]/255) ),
				element.scaleX or (element.scale or 0.9),
				element.scaleY or (element.scale or 0.9),
				element.font or 'default',
				element.alignX or 'center', 'center',
				false, false, false, true
			)
		end,

		clickbox = function(element, id)

			local drawFunc1 = dxDrawImage
			local drawFunc2 = dxDrawText
			local hoverFunc = isMouseInPosition
			if element.mtaDraw then
				drawFunc1 = mta_dxDrawImage
				drawFunc2 = mta_dxDrawText
				hoverFunc = mta_isMouseInPosition
			end

			local animData = element.animData
			local eColor = element.color or {255,255,255,255}

			local colorHover = element.activeColor
			local x,y,w,h = getElementAbsoluteOffset(element)

			local color = {unpack(eColor)}

			if not colorHover then
				colorHover = {
					color[1], color[2], color[3], color[4]
				}
				color[1] = color[1] * 0.8
				color[2] = color[2] * 0.8
				color[3] = color[3] * 0.8
			end

			colorHover[4] = eColor[4]

			if element.bg then

				local hr,hg,hb = interpolateBetween(
					color[1], color[2], color[3],
					colorHover[1], colorHover[2], colorHover[3],
					animData, 'Linear'
				)

				drawFunc1(
					x,y,w,h,
					element.bg, element.rot or 0, 0, 0,
					tocolor(
						hr,hg,hb,
						color[4]*windowAlpha
					)
				)
				if element.activeBg then
					drawFunc1(
						x,y,w,h,
						element.activeBg, element.rot or 0, 0, 0,
						tocolor(
							colorHover[1],colorHover[2],colorHover[3],
							colorHover[4]*animData*windowAlpha
						)
					)
				end
			end

			if element.activeFg then
				local r,g,b = unpack( element.activeFgColor or {255,255,255} )
				drawFunc1(
					x,y,w,h,
					element.activeFg, element.rot or 0, 0, 0,
					tocolor(
						r,g,b,
						animData*eColor[4]*windowAlpha
					)
				)
			end

			local textColor = element.textColor or {255,255,255}
			local activeTextColor = element.activeTextColor or textColor

			local tr,tg,tb = interpolateBetween(
				textColor[1], textColor[2], textColor[3],
				activeTextColor[1], activeTextColor[2], activeTextColor[3],
				animData, 'Linear'
			)

			local text = ((element.values or {})[element.selected or 1] or {}).text

			drawFunc2(text,
				x,y,x+w,y+h,
				tocolor(tr,tg,tb,255*windowAlpha* (color[4]/255) ),
				element.scaleX or (element.scale or 0.9),
				element.scaleY or (element.scale or 0.9),
				element.font or 'default',
				element.alignX or 'center', 'center',
				false, false, false, true
			)
		end,
		rectangle = function(element, id)

			local drawFunc = dxDrawRectangle
			local drawFunc2 = dxDrawImage
			local hoverFunc = isMouseInPosition
			if element.mtaDraw then
				drawFunc = mta_dxDrawRectangle
				drawFunc2 = mta_dxDrawImage
				hoverFunc = mta_isMouseInPosition
			end

			local color = element.color or {255,255,255,255}
			local x,y,w,h = getElementAbsoluteOffset(element)

			if element.activeColor then

				local animData = element.animData

				local alpha = color[4] + ( element.activeColor[4] - color[4] ) * animData
				color = {interpolateBetween(
					color[1], color[2], color[3],
					element.activeColor[1], element.activeColor[2], element.activeColor[3],
					animData, 'InOutQuad')}
				color[4] = alpha

			end

			drawFunc(
				x,y,w,h,
				tocolor(
					color[1],color[2],color[3],
					color[4]*windowAlpha
				)
			)

		end,
		input = function(element, id)


			local drawFunc1 = dxDrawRectangle
			local drawFunc2 = dxDrawImage
			local drawFunc3 = dxDrawText
			if element.mtaDraw then
				drawFunc1 = mta_dxDrawRectangle
				drawFunc2 = mta_dxDrawImage
				drawFunc3 = mta_dxDrawText
			end

			local inputId = id
			local curText = element.placeholder or ''
			local textIsPlaceholder = true
			local hideSymbols = false
			local x,y,w,h = getElementAbsoluteOffset(element)

			if selectedInput == element then
				element.focused = true
				curText = element[6]
				textIsPlaceholder = false
				hideSymbols = element.mask
			else
				element.focused = false
				hideSymbols = element.mask
				if utf8.len(element[6]) > 0 then
					curText = element[6]
					textIsPlaceholder = false
				end

				if element.handleText then
					curText = tostring(element.handleText(curText))
				end
			end

			if hideSymbols then
				if utf8.len(element[6]) > 0 then
					curText = ''
					for i = 1, utf8.len(element[6]) do
						curText = curText .. element.mask
					end
				end
			end

			local color = element.color or {255,255,255,255}

			local bg = element.bg
			if selectedInput == element then

				local r,g,b = unpack(element.activeColor or color)
				color = {r,g,b, element.color[4]}

				bg = element.activeBg or element.bg
			end


			local elementAlpha = color[4]/255

			if element.disabled then
				elementAlpha = elementAlpha * 0.5
			end

			if bg and (type(bg) ~= 'string' or fileExists(bg)) then
				drawFunc2(
					x,y,w,h,
					bg, 0, 0, 0,
					tocolor(
						color[1],color[2],color[3],
						255*elementAlpha*windowAlpha
					)
				)
			end

			local maxTextWidth = element.textAreaWidth or w*0.8
			local iconSize = 0
			if element.icon then
				local iconSize = element.iconSize or h*0.6
				local color = element.iconColor or {255,255,255,255}
				maxTextWidth = maxTextWidth - iconSize - 5

				local ix,iy,iw,ih =
					x + w - iconSize - 10,
					y + h/2 - iconSize/2,
					iconSize,
					iconSize

				element.__icon_coords = {ix,iy,iw,ih}

				drawFunc2(
					ix,iy,iw,ih,
					element.icon, 0, 0, 0,
					tocolor(
						color[1],color[2],color[3],
						color[4]*windowAlpha*elementAlpha
					)
				)
			end

			local scaleX, scaleY = 
				element.scaleX or (element.scale or 0.45),
				element.scaleY or (element.scale or 0.45)


			local color = element.textColor or {255,255,255,255}

			if selectedInput == element then
				color = element.activeTextColor or color
			end

			if textIsPlaceholder then
				color = element.placeholderColor or color
			end

			-- local textScaleMul = 1
			local hCurText = curText
			local textWidth = dxGetTextWidth(curText, scaleX, element.font or 'default')

			while (textWidth + 20) > px(maxTextWidth) do
				hCurText = utf8.sub(hCurText, 2)
				textWidth = dxGetTextWidth(hCurText,
					scaleX, element.font or 'default')
			end

			local alignX = element.alignX or 'left'
			local x1,y1,x2,y2 = x + 20,y,
				w + x - 20 - iconSize,
				y + h

			if alignX == 'center' then
				x1,y1,x2,y2 = x,y, x+w, y+h
			else
				x1 = x1 + (element.textPadding or 0)
			end

			if selectedInput == element then

				local height = h*0.5
				local anim = getAnimData('input-blim')

				if alignX == 'left' then
					local bx,by,bw,bh

					if element.mtaDraw then
						bx,by,bw,bh =
							x + 25 + (element.textPadding or 0) + textWidth,
							y + (h - height)/2,
							2,
							height
					else
						bx,by,bw,bh =
							px(x + 25 + (element.textPadding or 0)) + textWidth,
							px(y + (h - height)/2),
							px(2),
							px(height)
					end
					mta_dxDrawRectangle(
						bx,by,bw,bh,
						tocolor(
							color[1],color[2],color[3],
							color[4]*windowAlpha*elementAlpha*anim
						)
					)
				elseif alignX == 'center' then
					local add = 0
					if textWidth > 0 then
						add = 5
					end

					local bx,by,bw,bh

					if element.mtaDraw then
						bx,by,bw,bh =
							x + textWidth/2 + element[4]/2 + add,
							y + (element[5] - height)/2,
							2, height
					else
						bx,by,bw,bh =
							px(x + w/2 + add) + textWidth/2,
							px(y + (h - height)/2),
							px(2),
							px(height)
					end
					mta_dxDrawRectangle(
						bx,by,bw,bh,
						tocolor(
							color[1],color[2],color[3],
							color[4]*windowAlpha*elementAlpha*anim
						)
					)
				end

			end

			drawFunc3(hCurText,
				x1,y1,x2,y2,
				tocolor(
					color[1],color[2],color[3],
					color[4]*windowAlpha*elementAlpha
				),
				scaleX,scaleY,
				element.font or 'default',
				alignX, 'center',
				false, false, false, false
			)
		end,

		textarea = function(element, id)


			local drawFunc1 = dxDrawRectangle
			local drawFunc2 = dxDrawImage
			local drawFunc3 = dxDrawText
			if element.mtaDraw then
				drawFunc1 = mta_dxDrawRectangle
				drawFunc2 = mta_dxDrawImage
				drawFunc3 = mta_dxDrawText
			end

			local inputId = id
			local curText = element.placeholder or ''
			local textIsPlaceholder = true

			local render_text = utf8.gsub(element.render_text, '\n', '')
			if render_text ~= element[6] then
				element.render_text = element[6]
			end

			local x,y,w,h = getElementAbsoluteOffset(element)

			if selectedInput == element then

				curText = element.render_text
				
				textIsPlaceholder = false
				element.focused = true

			else
				element.focused = false

				if utf8.len(element.render_text) > 0 then
					curText = element.render_text
					textIsPlaceholder = false
				end

				if element.handleText then
					curText = tostring(element.handleText(curText))
				end
			end

			local color = element.color or {255,255,255,255}

			local bg = element.bg
			if selectedInput == element then
				color = element.activeColor or color
				bg = element.activeBg or element.bg
			end

			local elementAlpha = color[4]/255

			if bg and (type(bg) ~= 'string' or fileExists(bg)) then
				drawFunc2(
					x,y,w,h,
					bg, 0, 0, 0,
					tocolor(
						color[1],color[2],color[3],
						color[4]*windowAlpha
					)
				)
			end

			local scaleX, scaleY = 
				element.scaleX or (element.scale or 1),
				element.scaleY or (element.scale or 1)


			local color = element.textColor or {255,255,255,255}

			if selectedInput == element then
				color = element.activeTextColor or color
			end

			if textIsPlaceholder then
				color = element.placeholderColor or color
			end

			local padding = element.padding or 0

			local x,y = x + padding, y + padding

			if selectedInput == element then
				if inputBlim then

					local height = element.fontHeight

					local text = splitString(element.render_text, '\n')
					local offset = (#text-1) * height

					local lastRow = text[#text]
					local width = dxGetTextWidth(lastRow, element.scale, element.font) * sx/real_sx

					local bx,by = x + width + 3, y + offset

					dxDrawRectangle(
						bx,by, 3, height,
						tocolor(
							color[1],color[2],color[3],
							color[4]*windowAlpha*elementAlpha
						)
					)

				end
			end

			drawFunc3(element.render_text,
				x,y,x,y,
				tocolor(
					color[1],color[2],color[3],
					color[4]*windowAlpha*elementAlpha
				),
				scaleX,scaleY,
				element.font or 'default',
				'left', 'top',
				false, false, false, false
			)
		end,

		checkbox = function(element, id)


			local drawFunc1 = dxDrawImage
			local hoverFunc = isMouseInPosition
			if element.mtaDraw then
				drawFunc1 = mta_dxDrawImage
				hoverFunc = mta_isMouseInPosition
			end

			local x,y,w,h = getElementAbsoluteOffset(element)

			element.c_animId = element.c_animId or {}
			local animId = element.c_animId
			local animData = getAnimData(animId)

			if not animData then
				animData = 0
				setAnimData(animId, 0.1, 0)
			end

			animData = getEasingValue(animData, 'InOutQuad')

			if element.checked then
				animate(animId, 1)
			else
				animate(animId, 0)
			end

			local color = element.color or {255,255,255,255}

			local fgColor = element.fgColor or color
			local activeColor = element.activeColor or fgColor

			local r,g,b = interpolateBetween(
				fgColor[1], fgColor[2], fgColor[3],
				activeColor[1], activeColor[2], activeColor[3],
				animData, 'Linear'
			)

			local elementAlpha = color[4]/255
			
			drawFunc1(
				x,y,w,h,
				element.bg or ':core/assets/images/checkbox_bg.png', 0, 0, 0, 
				tocolor(color[1], color[2], color[3],
					color[4]*windowAlpha*elementAlpha)
			)

			local size = element.size or 46
			local padding = (h - size)/2 + (element.padding or 0)

			local x0, xe = x + padding, x + w - padding - size
			local bx = x0 + (xe - x0)*animData

			drawFunc1(
				bx, y + h/2 - size/2,
				size, size,
				element.fg or ':core/assets/images/checkbox_body.png', 0, 0, 0, 
				tocolor(r,g,b,
					color[4]*windowAlpha*elementAlpha)
			)

			local hovered = hoverFunc(x,y,w,h)

			if handleClick and hovered then

				element.checked = not element.checked
				element:callHandler('onCheck', element.checked)
				handleClick = false

			end

		end,

		slider = function(element, id)

			local drawFunc1 = dxDrawImage
			local drawFunc2 = dxDrawImageSection
			if element.mtaDraw then
				drawFunc1 = mta_dxDrawImage
				drawFunc2 = mta_dxDrawImageSection
			end

			local x,y,w,h = getElementAbsoluteOffset(element)

			local color = element.color or {255,255,255,255}
			local activeColor = element.activeColor or color

			local r,g,b,a = unpack(color)
			local ar,ag,ab = unpack(activeColor)

			local sliderColor = element.sliderColor or activeColor
			local sr,sg,sb = unpack(sliderColor)


			local elementAlpha = color[4]/255

			local min, max = unpack(element.range or {0,1})
			local percent = math.clamp((element.value-min)/(max-min), 0, 1)

			local texture = getDrawingTexture(element.bg)
			local mw,mh = dxGetMaterialSize( texture )

			drawFunc2(
				x,y,
				w * percent, h,
				0, 0,
				mw * percent, mh,
				texture,
				0,0,0, tocolor(ar,ag,ab, a*windowAlpha*elementAlpha)
			)

			drawFunc2(
				x + w * percent, y,
				w - w * percent, h,
				mw * percent, 0,
				mw - mw * percent, mh,
				texture,
				0,0,0, tocolor(r,g,b, a*windowAlpha*elementAlpha)
			)

			if element.slider then
				local size = element.sliderSize or (h + 20)
				local x = x + w*percent

				drawFunc1(
					x - size/2, y + h/2 - size/2,
					size, size,
					element.slider, 0, 0, 0, 
					tocolor(sr,sg,sb, a*windowAlpha*elementAlpha)
				)
			end

		end,

		list = function(element, id)

			local drawFunc1 = dxDrawRectangle
			local drawFunc2 = dxDrawImage
			local drawFunc3 = dxDrawText
			local hoverFunc = isMouseInPosition
			if element.mtaDraw then
				drawFunc1 = mta_dxDrawRectangle
				drawFunc2 = mta_dxDrawImage
				drawFunc3 = mta_dxDrawText
				hoverFunc = mta_isMouseInPosition
			end

			local x,y,w,h = getElementAbsoluteOffset(element)

			local color = element.color or {255,255,255,255}

			if element.bg then

				local bgColor = element.bgColor or {255,255,255,255}

				drawFunc2(
					x,y,w,h,
					element.bg, 0,0,0,
					tocolor(bgColor[1], bgColor[2], bgColor[3], bgColor[4]*windowAlpha*(color[4]/255))
				)

			end

			local width,height = w,h
			if not element.renderTarget then
				if not element.mtaDraw then
					width,height = px(width), px(height)
				end

				element.renderTarget = dxCreateRenderTarget(width, height, true)
			end

			local elementHeight = getListAverageElementHeight(element)
			-- local elementHeight = element.listElementHeight or 35
			local elements = element.listElements or {}

			element.listOffset = math.max(
				element.listOffset or 0,
				-#elements
			)
			local offset = element.listOffset or 0

			local activeColor = element.activeColor or color

			local scaleX, scaleY = 
				element.scaleX or (element.scale or 0.45),
				element.scaleY or (element.scale or 0.45)

			element.visibleElements = element.visibleElements or math.floor(h / elementHeight)
			element.visibleElements = math.max(0, element.visibleElements)

			element.l_animId = element.l_animId or {}
			local animId = element.l_animId

			local animY, target = getAnimData(animId)
			if not tonumber(animY) then
				animY = 0
				setAnimData(animId, element.animSpeed or 0.1, 0)
			end

			animate(animId, offset)

			local textPadding = element.textPadding or 0

			local offset_y = -math.floor(animY) + 1
			local elementY = animY*elementHeight

			dxSetBlendMode('modulate_add')

			dxSetRenderTarget(element.renderTarget, true)

				for index = 1, offset_y + element.visibleElements+1 do

					local listElement = elements[index]
					if listElement then

						elementY = math.floor(elementY)

						local dColor = listElement.color or color
						local aColor = listElement.activeColor or activeColor

						listElement.l_animId = listElement.l_animId or {}
						local animId = listElement.l_animId

						animate(animId, element.selectedItem == index and 1 or 0)

						local animData = getAnimData(animId)
						if not tonumber(animData) then
							animData = 0
							setAnimData(animId, 0.1, 0)
						end

						local lec = {interpolateBetween(
							dColor[1], dColor[2], dColor[3],
							aColor[1], aColor[2], aColor[3],
							animData, 'InOutQuad'
						)}

						lec[4] = color[4]

						if elementY > (- (listElement.height or element.listElementHeight) ) and elementY < height then

							if element.lastSelectedItem and element.selectedItem then

								local wrongSelectionFlag

								if element.wrongSelection then
									wrongSelectionFlag = element.wrongSelection(
										element.lastSelectedItem, elements[element.selectedItem])
								else
									wrongSelectionFlag = element.lastSelectedItem ~= elements[element.selectedItem]
								end

								if wrongSelectionFlag then
									element.selectedItem = false
									element.lastSelectedItem = false
								end

							end

							local lElementHovered = hoverFunc(
								x,
								y + elementY,
								w,
								elementHeight
							)
							if not element.noHandleHover and lElementHovered then

								local lx,ly = x,y

								for _, handler in pairs( listElement.clickHandlers or {} ) do
									local hx,hy,hw,hh = unpack(handler.coords or handler.getCoords(
										element,
										0, elementY
									))

									handler.hovered = hoverFunc(
										lx + hx,
										ly + hy,
										hw,
										hh
									)

									if handler.hovered then
										if handleClick then
											if handler.handle then
												handler.handle(listElement, index, element, handler)
												handleClick = false
											end
										end
									end

								end

								if handleClick then

									if not element.noSelection and not listElement.disabled then
										element.selectedItem = index
										element.lastSelectedItem = listElement
										handleClick = false
									end

									if element.onListElementClick then
										element.onListElementClick(element, listElement, index, currentButtonHandle)
										handleClick = false
									end

								end

							else
								for _, handler in pairs( listElement.clickHandlers or {} ) do
									handler.hovered = false
								end
							end

							local text = listElement.text
							if element.getListElementText then
								text = element.getListElementText(element, listElement, index)
							end

							if text then
								for i = 1,2 do
									drawFunc3(text or '',
										0 + textPadding,
										elementY,
										width + textPadding, elementY + elementHeight,
										tocolor(
											lec[1],lec[2],lec[3],
											lec[4]*windowAlpha
										),
										scaleX, scaleY,
										element.font or 'default',
										listElement.alignX or (element.alignX or 'left'), 'center',
										false, true, false, true
									)
								end
							end

							if element.additionalElementDrawing then
								element.additionalElementDrawing(
									listElement, 
									0,
									elementY,
									w,
									listElement.height or element.listElementHeight,
									element, animData, index, lElementHovered

								)
							end

						end

						elementY = elementY + (listElement.height or element.listElementHeight)

					end

				end


			dxSetRenderTarget()

			dxSetBlendMode('blend')

			if isElement(element.renderTarget) then
				dxDrawImage(
					x,y,w,h,
					element.renderTarget,
					0, 0, 0, tocolor(255,255,255,windowAlpha*element.color[4])
				)
			end

			if #elements*elementHeight > height and element.scrollBg then

				element.s_animId = element.s_animId or {}
				local s_animId = element.s_animId

				local scrollHeight = element.scrollHeight or 1

				scrollHeight = element[5] * scrollHeight

				local scrollY = scrollHeight and (
					y + h/2 - scrollHeight/2
				) or y

				scrollY = scrollY + (element.scrollYOffset or 0)

				local scrollColor = element.scrollColor or {255,255,255,255}
				local scrollBgColor = element.scrollBgColor or {255,255,255,255}

				local scrollWidth = element.scrollWidth or 5
				local sHeight = scrollHeight * height / (#elements*elementHeight)
				sHeight = math.max(sHeight, 10)

				local y = scrollY + ((scrollHeight) * (-offset)/#elements )

				y = math.min(y, scrollY + scrollHeight - sHeight)

				element.s_animId = element.s_animId or {}
				local s_animId = element.s_animId

				animate(s_animId, y)

				local animY = getAnimData(s_animId)
				if not tonumber(animY) then
					animY = scrollY
					setAnimData(s_animId, element.animSpeed or 0.1, scrollY)
				end

				local scrollX = x + w + 8 + (element.scrollXOffset or 0)

				drawFunc2(
					scrollX,
					scrollY, scrollWidth, scrollHeight,
					element.scrollBg, 0, 0, 0,
					tocolor(
						scrollBgColor[1],scrollBgColor[2],
						scrollBgColor[3],scrollBgColor[4]*windowAlpha*(color[4]/255)
					)
				)

				drawFunc2(
					scrollX,
					animY, scrollWidth, sHeight,
					element.scrollBg, 0, 0, 0,
					tocolor(
						scrollColor[1],scrollColor[2],
						scrollColor[3],scrollColor[4]*windowAlpha*(color[4]/255)
					)
				)

				if handleClick then


					local s_x,s_y,s_w,s_h = scrollX, scrollY, scrollWidth, scrollHeight

					if not element.mtaDraw then
						s_x,s_y,s_w,s_h = px(s_x), px(s_y), px(s_w), px(s_h)
					end

					if mta_isMouseInPosition(s_x,s_y,s_w,s_h) then

						local x,y = getCursorPosition()
						x,y = x * real_sx, y * real_sy

						x,y = x-s_x, y-s_y

						local yState = y/s_h

						element.listOffset = -(yState * #elements) + element.visibleElements
						element.listOffset = math.min(0, element.listOffset)

						handleClick = false
					end
				end
			end


		end,

		select = function(element, id)

			local drawFunc1 = dxDrawRectangle
			local drawFunc2 = dxDrawText
			local drawFunc3 = dxDrawImage
			local hoverFunc = isMouseInPosition
			if element.mtaDraw then
				drawFunc1 = mta_dxDrawRectangle
				drawFunc2 = mta_dxDrawText
				drawFunc3 = mta_dxDrawImage
				hoverFunc = mta_isMouseInPosition
			end

			local r,g,b,a = unpack(element.color or {255,255,255,255})
			local tr,tg,tb,ta = unpack(element.textColor or {0,0,0,255})

			if element.placeholderColor and not element.selectedItem then
				tr,tg,tb,ta = unpack(element.placeholderColor or {0,0,0,255})
			end

			local x,y,w,h = getElementAbsoluteOffset(element)

			local selectList = element.selectList
			local animData = getAnimData(element.select_animData)
			animData = getEasingValue(animData, 'InOutQuad')

			if element.bg then
				drawFunc3(
					x,y,w,h,
					element.bg,
					0, 0, 0,
					tocolor(r,g,b,a*windowAlpha)
				)			
			else
				drawFunc1(
					x,y,w,h,
					tocolor(r,g,b,a*windowAlpha)
				)
			end

			if element.icon then
				local size = element.iconSize or h*0.8
				local offset = (h - size)/2

				local ir,ig,ib,ia = unpack( element.iconColor or {255,255,255} )
				ia = a

				drawFunc3(
					x + w - size - offset, y + offset,
					size, size,
					element.icon,
					animData*180,
					0, 0, tocolor(ir,ig,ib,ia*windowAlpha)
				)

			end

			local slx, sly, slw, slh = selectList:abs()

			if isElement(element.list_bg) or fileExists(element.list_bg) then
				drawFunc3(
					slx, sly-5, slw, slh+10,
					element.list_bg, 0, 0, 0,
					tocolor(r,g,b,a*animData*windowAlpha)
				)		
			else
				drawFunc1(
					slx, sly-5, slw, slh+10,
					tocolor(r,g,b,a*animData*windowAlpha)
				)	
			end

			local textPadding = (element.alignX or 'left') == 'center' and 0 or 20

			drawFunc2(element.selectedItem and (
				element.getSelectedText and element:getSelectedText() or element.selectedItem.text
			) or element.placeholder,
				x + textPadding, y,
				x + w + textPadding,
				y + h,
				tocolor(tr,tg,tb,ta*windowAlpha),
				element.scale or 1, element.scale or 1,
				element.font or 'default',
				element.alignX, 'center'
			)

			if hoverFunc(x,y,w,h) then

				if handleClick then

					if activeSelect == element then
						animate(activeSelect.select_animData, 0)
						activeSelect = false
					else
						activeSelect = element
						animate(element.select_animData, 1)
					end

				end

			end


		end,
	}

-----INITIALIZE-------------------------------------------------------

	initializeFunctions = {

		list = function(element)

			element.scrollTo = function(element, lElement)

				local x,y,w,h = getElementAbsoluteOffset(element)

				for index, listElement in pairs( element.listElements ) do
					if listElement == lElement then

						local visible = math.floor( h / element.listElementHeight )
						element.listOffset = (
							- ( index-1 ) * element.listElementHeight
							+ ( visible - 1 ) * element.listElementHeight
							- math.abs( math.min( index - visible, 0 ) ) * element.listElementHeight
						) / element.listElementHeight

					end
				end

			end

			element.move = function(element, delta)
			
				local selectedItem = element.selectedItem or 0

				element.selectedItem = cycle( selectedItem + delta, 1, #element.listElements )
				element.lastSelectedItem = element.listElements[element.selectedItem]

				if element.onListElementClick then
					element:onListElementClick(element.lastSelectedItem)
				end

			end


		end,

		select = function(element, elementId, section)

			element.select_animData = element.select_animData or {}
			setAnimData(element.select_animData, element.animSpeed or 1)

			local lHeight = element.listElementHeight or element[5]

			local elementHeight = math.min(
				element.selectHeight or lHeight*4,
				(element.selectHeight or lHeight) * #element.selectElements
			)

			if element.selectList then
				element.selectList.listElements = element.selectElements or {}
			else
				local window = windowModel[section]

				element.selectList = element:addElement(
					{
						'list',
						0, element[5]+10,
						element[4],
						elementHeight,
						scrollBg = element.scrollBg or scrollTexture,
						scrollBgColor = element.scrollBgColor or {27,32,54,255},
						scrollColor = element.scrollColor or {180,70,70,255},
						color = table.copy(element.textColor or {255,255,255,255}),

						scollWidth = 5,
						scrollXOffset = -22,
						scrollHeight = 0.8,

						animationAlpha = element.select_animData,

						parent = element,

						listElements = element.selectElements or {},
						listElementHeight = lHeight,

						font = element.font,
						scale = element.scale,

						alignX = element.alignX or 'left',
						textPadding = (element.alignX or 'left') == 'center' and 0 or 20,

						additionalElementDrawing = element.additionalElementDrawing,

						onListElementClick = function(element, lElement, index)

							local _, target = getAnimData(element.animationAlpha)
							if target == 0 then
								element.lastSelectedItem = false
								element.selectedItem = false
								return
							end

							element.parent.selectedItem = lElement
							if element.parent.onSelect then
								element.parent.onSelect(element.parent, lElement)
							end

							activeSelect = nil
							animate(element.animationAlpha, 0)
						end,
					}

				)


				for index, item in pairs( element.selectElements ) do
					if item.selected then
						element.selectedItem = element.selectElements[index]
					end
				end

			end

	
		end,

		clickbox = function(element)

			element.select = function(element, index)

				element.values = element.values or {}
				element.selected = index
				element[6] = (element.values[element.selected] or {}).text or ''

				element:callHandler('onChange', element.values[element.selected], element.selected)

			end

			if element.initSelect ~= false then
				element:select(element.selected or 1)
			end

		end,

		slider = function(element, elementId, section)

			if not (element.cancelSlide or element.slide == false) then

				element:addHandler('onScroll', function(element, side)

					local total = element.range[2] - element.range[1]
					local add = total*(side == 'down' and 1 or -1)*0.05

					element.value = math.clamp( element.value + add, unpack(element.range) )

					element:callHandler('onSlide', element.value)

				end)

				element.onDragDrop = function(element, x,y)

					local ex,ey,ew,eh = getElementAbsoluteOffset(element)

					local hx,hy = x,y
					if element.mtaDraw then
						hx,hy = px(x), px(y)
					end

					local progress = hx/ew

					local min,max = unpack(element.range or {0,1})
					local value = min + (max - min)*progress

					element.value = value

					element:callHandler('onSlide', value, progress)

				end

				element.onClick = function(element, pos)

					local x,y,w,h = getElementAbsoluteOffset(element)

					local hx,hy

					-- if element.mtaDraw then
						hx,hy = pos[1], pos[2]
					-- else
					-- 	hx,hy = pos[1] * sx/real_sx, pos[2] * sx/real_sx
					-- end

					local progress = hx/w

					local min,max = unpack(element.range or {0,1})
					local value = min + (max - min)*progress

					element.value = value

					if element.onSlide then
						element.onSlide(element, value, progress)
					end


				end
			end
	
		end,

		textarea = function(element, elementId, section)

			element.fontHeight = dxGetFontHeight(element.scale, element.font)

			element.maxRowWidth = element[4] - (element.padding or 0)*2

			element.render_text = ''
			element._ontextareainput = function(element, text)

				if not text then

					element.render_text = utf8.sub(element.render_text, 0, -2)

					local lastSymbol = utf8.sub(element.render_text, -1)
					if lastSymbol == '\n' then
						element.render_text = utf8.sub(element.render_text, 0, -2)
					end

				else

					for _, symbol in pairs( string.split(text, '') ) do

						local splitted = splitString(element.render_text, '\n')

						local curRow = splitted[#splitted]
						local str = curRow .. symbol

						local width = dxGetTextWidth(str, element.scale, element.font)

						if math.abs(width - element.maxRowWidth) < 10 then
							element.render_text = element.render_text .. '\n' .. symbol
						else
							element.render_text = element.render_text .. symbol
						end 

					end

				end

			end

		end,

		input = function(element)

			element.blur = function(element)

				if not element.focused then return end

				element.focused = false
				selectedInput = false

			end

			element.focus = function(element)

				focusInput(element)

			end

		end,

	}

	function createElementVerticalOverflow(element)

		element.ov_animId = {}
		setAnimData(element.ov_animId, element.scroll_speed or 0.1, 0)

		element.update_endY = function(element)

			local endY = element[5]

			for _, c_element in pairs( element.elements or {} ) do

				local _endY = c_element[3] + c_element[5]
				if _endY > endY then
					endY = _endY
				end

			end

			-- endY = endY - element[5]
			element.ov_endY = endY

		end

		element.update_scroll_tex = function(element)

			if element.ov_endY == 0 then return end

			local scroll_height = element[5]*(element.scrollHeight or 0.8)
			local scroll_height_a = math.max(1, scroll_height * element[5]/(element.ov_endY))

			if scroll_height_a ~= element.scroll_height_a then

				element.scroll_height = scroll_height
				element.scroll_height_a = scroll_height_a

				local w = element.scrollWidth or 7

				element.scroll_bg = whiteTexture
				element.scroll_abg = whiteTexture

				-- element.scroll_bg = createTextureSource( 'bordered_rectangle', 'voscroll.png', w, w, element.scroll_height )
				-- element.scroll_abg = createTextureSource( 'bordered_rectangle', 'voscroll_a.png', w, w, element.scroll_height_a )

			end

		end

		element:update_endY()
		element:update_scroll_tex()

		element:addHandler('onScroll', function(element, side)

			local scrollStep = element.scroll_step or 100

			element:update_endY()
			element:update_scroll_tex()

			local delta = side == 'up' and 1 or -1

			local _, _animY = getAnimData(element.ov_animId)

			local animY = math.clamp( _animY + delta*scrollStep, -(element.ov_endY-element[5]), 0 )

			animate(element.ov_animId, animY)

		end)

		element:addHandler('lOnPostRender', function(element)

			local x,y,w,h = element:abs()
			local alpha = element:alpha()

			-- print(getTickCount(  ), element.ov_endY)
			if element.ov_endY > element[5] then
			-- if element.ov_endY > element[5] then

				local scx,scy,scw,sch = x+w+(element.scrollXOffset or -20), y+h/2 - element.scroll_height/2, element.scrollWidth or 7, element.scroll_height

				local r,g,b = unpack(element.scrollBgColor or {45,50,90})
				local ar,ag,ab = unpack(element.scrollColor or {180,70,70})

				dxDrawImage(
					scx,scy,scw,sch, element.scroll_bg,
					0, 0, 0, tocolor(r,g,b,255*alpha)
				)

				local animY = getAnimData(element.ov_animId)

				local progress = -( animY / ( element.ov_endY - element[5] ) )

				local sch_a = element.scroll_height_a
				local py = ( sch - sch_a )*progress

				dxDrawImage(
					scx,scy+py,scw,sch_a, element.scroll_abg,
					0, 0, 0, tocolor(ar,ag,ab,255*alpha)
				)

			end

			element:update_endY()
			element:update_scroll_tex()

		end)

	end

	function createElementHorizontalOverflow(element)

		element.ov_animId = {}
		setAnimData(element.ov_animId, element.scroll_speed or 0.1, 0)

		element.update_endX = function(element)

			local endX = element[4]

			for _, c_element in pairs( element.elements or {} ) do

				local _endX = c_element[2] + c_element[4]
				if _endX > endX then
					endX = _endX
				end

			end

			endX = endX - element[4]
			element.ov_endX = endX

		end

		element:update_endX()

		element:addHandler('onScroll', function(element, side)

			local scrollStep = element.scroll_step or 100

			element:update_endX()

			local delta = side == 'up' and 1 or -1

			local _, _animX = getAnimData(element.ov_animId)

			local animX = math.clamp( _animX + delta*scrollStep, -element.ov_endX, 0 )

			animate(element.ov_animId, animX)

		end)

	end

	local guiModuleLoaded = false

	GUIDefine_data = {}

	function GUIDefine(element_type, data)
		GUIDefine_data[ element_type ] = data
	end

	elements_links = {}

	function initializeElement( sectionName, elementId, element )

		if element.define_from ~= false and GUIDefine_data[ element.define_from or element[1] ] then

			for key, value in pairs( GUIDefine_data[ element.define_from or element[1] ] ) do
				if element[key] == nil then
					element[key] = value
				end
			end

		end

		if element.variable then
			_G[element.variable] = element
		end

		if element.id then
			elements_links[sectionName] = elements_links[sectionName] or {}
			elements_links[sectionName][element.id] = element
		end

		if not element.startcolor then
			if element.color then
				element.startcolor = element.color[4]
			else
				element.startcolor = 255
			end
		end

		element.animData = 0

		element.abs = function(self, ...)
			return getElementAbsoluteOffset(self, ...)
		end

		element.alpha = function(self)
			return getElementAbsoluteAlpha(self)
			-- return getElementDrawAlpha(self)
		end

		if type(element[4]) == 'string' and element[4]:sub(-1) == ('%') then
			local percent = tonumber( element[4]:sub(0, -2) ) / 100
			if element.parent then
				element[4] = element.parent[4] * percent
			else
				element[4] = sx * percent
			end
		elseif type(element[4]) == 'function' then
			element[4] = (element[4])(element, element.parent or { 'root', 0, 0, sx,sy })
		end

		if type(element[5]) == 'string' and element[5]:sub(-1) == ('%') then
			local percent = tonumber( element[5]:sub(0, -2) ) / 100
			if element.parent then
				element[5] = element.parent[5] * percent
			else
				element[5] = sy * percent
			end
		elseif type(element[5]) == 'function' then
			element[5] = (element[5])(element, element.parent or { 'root', 0, 0, sx,sy })
		end

		if element[2] == 'center' then
			if element.parent then
				element[2] = element.parent[4]/2 - element[4]/2
			else
				element[2] = sx/2 - element[4]/2
			end
		elseif element[2] == 'right' then
			if element.parent then
				element[2] = element.parent[4] - element[4]
			else
				element[2] = sx - element[4]
			end
		elseif element[2] == 'left' then
			element[2] = 0
		elseif type(element[2]) == 'function' then
			element[2] = (element[2])(element, element.parent or { 'root', 0, 0, sx,sy })
		end

		if element[3] == 'center' then
			if element.parent then
				element[3] = element.parent[5]/2 - element[5]/2
			else
				element[3] = sy/2 - element[5]/2
			end
		elseif element[3] == 'bottom' then
			if element.parent then
				element[3] = element.parent[5] - element[5]
			else
				element[3] = sx - element[5]
			end
		elseif element[3] == 'top' then
			element[3] = 0
		elseif type(element[3]) == 'function' then
			element[3] = (element[3])(element, element.parent or { 'root', 0, 0, sx,sy })
		end


		if not element.__data then
			element.__data = {
				id = elementId,
				section = sectionName,
				__alpha0 = (element.color or {255,255,255,255})[4] or 255,
			}
		end

		if not element.destroy then

			element.destroy = function( element )

				element:callHandler('onDestroy')

				for _, c_element in pairs(element.elements or {}) do
					c_element:destroy()
				end

				if element[1] == 'select' then
					element.selectList:destroy()
				end

				if element.parent then
					if element.parent.elements then
						element.parent.elements[ element.__data.id ] = nil
					end
				else
					windowModel[ element.__data.section ][ element.__data.id ] = nil
				end

				element:callHandler('onPostDestroy')

			end

		end

		if not element.addElement then

			element.addElement = function( element, __table, index )

				local _table = table.copy(__table)

				_table.parent = element

				element.elements = element.elements or {}

				if index then
					table.insert(element.elements, index, _table)
				else
					table.insert(element.elements, _table)
				end

				for index, c_element in pairs( element.elements ) do

					if c_element == _table then
						return initializeElement( element.__data.section, index, c_element )
					end

					if c_element.__data then
						c_element.__data.id = index
					end

				end

				return _table

			end

		end

		if not element.addHandler then

			element.addHandler = function( element, handler_name, func, order )

				local handlers = element[handler_name] or {}

				if type(handlers) == 'function' then
					handlers = { element[handler_name] }
				end

				if order then
					table.insert( handlers, order, func )
				else
					table.insert( handlers, func )
				end

				element[handler_name] = handlers

			end

			element.callHandler = function( element, handler_name, ... )

				local handler = element[handler_name]
				if not handler then return end

				if type(handler) == 'function' then

					handler(element, ...)

				elseif type(handler) == 'table' then

					for _, _handler in pairs(handler) do
						_handler(element, ...)
					end

				end

			end

		end

		if not element.__init  then

			if initializeFunctions[element[1]] then

				( initializeFunctions[element[1]] )( element, elementId, sectionName )

			end

			element:callHandler('onInit')

			element.__init = true

		end


		for index, child in pairs( element.elements or {} ) do
			child.parent = element
			initializeElement( sectionName, index, child )
		end

		if element.overflow == 'vertical' then
			createElementVerticalOverflow(element)
		elseif element.overflow == 'horizontal' then
			createElementHorizontalOverflow(element)
		end

		element:callHandler('onPostInit')

		local animId = element
		element.animId = element
		setAnimData(element.animId, 0.1, 0)

		return element

	end

	function initializeSection( sectionName, section )

		for elementId, element in pairs(section) do
			initializeElement( sectionName, elementId, element )
		end

	end

	function loadGuiModule()

		if not guiModuleLoaded then
			setAnimData('dxGui.window-alpha', windowAnimSpeed or 0.1)
		end

		if windowModel.__basic and not guiModuleLoaded then

			for sectionName, section in pairs(windowModel) do

				if not __basic_Ignore[sectionName] and sectionName ~= '__basic' then
					for index, element in pairs( table.reverse(windowModel.__basic) ) do
						table.insert(section, 1, element)
					end				
				end

			end

		end

		for sectionName, section in pairs(windowModel) do
			initializeSection( sectionName, section )
		end


		if not guiModuleLoaded then

			if openHandler then
				table.insert( openHandlers, openHandler )
			end

			if closeHandler then
				table.insert( closeHandlers, closeHandler )
			end

			setTimer(function()
				animate('input-blim', inputBlim and 1 or 0)
				inputBlim = not inputBlim
			end, 600, 0)
			
		end

		guiModuleLoaded = true

	end

-----UTILS-------------------------------------------------------

	function getElementDrawAlpha(element)
		return element.color[4]*windowAlpha/(element.__data.__alpha0 or 255)
	end

	function getGUIElementsByType(element_type)

		local elements = {}

		for _, element in pairs( windowModel[currentWindowSection] ) do

			if element[1] == element_type then
				table.insert(elements, element)
			end

			local _elements = element.elements

			while _elements do
				for _, _element in pairs( _elements ) do
					if _element[1] == element_type then
						table.insert(elements, _element)
					end
					_elements = _element.elements
				end
			end

		end

		return elements

	end

	function getListAverageElementHeight(list)

		local height = 0
		local dHeight = list.listElementHeight or 35

		if #list.listElements == 0 then
			return dHeight
		end

		for _, element in pairs(list.listElements) do
			height = height + ( element.height or dHeight )
		end

		return height / #(list.listElements)
	end

	function clearAllInputs()
		for _, section in pairs(windowModel) do
			for index, element in pairs(section) do
				if (element[1] == 'input') or (element[1] == 'textarea') then element[6] = '' end
			end
		end
	end

	function focusInput(element)
		if selectedInput then
			selectedInput.focused = false
		end

		element.focused = true

		selectedInput = element

		element:callHandler('onFocus')

		guiSetInputMode("no_binds")

	end

	function gui_get(id, section)
		if not elements_links[section or currentWindowSection] then return end
		return elements_links[section or currentWindowSection][id]
	end

	function deleteElementById(id)

		local env = _element and (_element.elements or {}) or windowModel[currentWindowSection]

		for index, element in pairs(env) do
			if id == element.id then
				element:destroy()
			end
		end
	end

	function animate_timed(animData, time, to_1, to_2)
		if isTimer(animate_timed_timer) then killTimer(animate_timed_timer) end
		animate(animData, to_1)
		animate_timed_timer = setTimer(function(animData, to)
			animate(animData, to)
		end, time, 1, animData, to_2)
	end

	function deleteCurInputSymbol()
		if not selectedInput then return end
		if not currentWindowSection then return end
		local element = selectedInput
		if element then
			local prev = element[6]
			element[6] = utf8.sub(element[6], 0, utf8.len(element[6]) - 1)

			if element._ontextareainput then
				element._ontextareainput(element)
			end

			if element.onInput then
				element.onInput(element, false, prev)
			end

		end
	end

	function scrollList(element, offset)
		activeList = element
		scrollActiveList(offset)
		activeList = false
	end

	function scrollActiveList(eOffset)

		local element = activeList

		if element then
			local _offset = (element.listOffset or 0) + eOffset * (element.scrollStep or 1) 

			element.listOffset = math.clamp(_offset, -#element.listElements + element[5]/( getListAverageElementHeight(element) ), 0)

		end

	end



-----WINDOW OPEN-------------------------------------------------------

	function toggleWindowOpened()
		
		windowOpened = not windowOpened

		if windowOpened then

			showCursor(true)

			if openHandlers then
				for _, handler in pairs( openHandlers ) do
					handler(handleResourceStop, unpack(currentWindowArgs or {}))
				end
			end

			if not windowRender then
				addEventHandler('onClientRender', root, drawWindow, true, windowPriority or 'low-2')
				windowRender = true
			end
			addEventHandler('onClientClick', root, onClick) 
			addEventHandler('onClientCursorMove', root, onCursorMove)
			addEventHandler('onClientCharacter', root, onCharacter)
			addEventHandler('onClientKey', root, onKey)
			addEventHandler('onClientPaste', root, onPaste)

			addCurrentWindow()

			animate('dxGui.window-alpha', 1)

			-- if refreshWindowSources_query then
			-- 	refreshWindowSources()
			-- 	refreshWindowSources_query = false
			-- end

		else

			showCursor(false)
			dragDropFlag = false

			if closeHandlers then
				for _, handler in pairs( closeHandlers ) do
					handler(handleResourceStop)
				end
			end

			removeCurrentWindow()

			animate('dxGui.window-alpha', 0)

			removeEventHandler('onClientClick', root, onClick) 
			removeEventHandler('onClientCursorMove', root, onCursorMove)
			removeEventHandler('onClientCharacter', root, onCharacter)
			removeEventHandler('onClientKey', root, onKey)
			removeEventHandler('onClientPaste', root, onPaste)

		end

		selectedInput = false
		guiSetInputMode("allow_binds")

	end

	function setWindowOpened(state)
		if state then
			if not windowOpened then
				toggleWindowOpened()
			end
		else
			if windowOpened then
				toggleWindowOpened()
			end
		end
	end

	addEventHandler('onClientResourceStop', resourceRoot, function()
		if windowOpened then
			handleResourceStop = true
			setWindowOpened(false)
			destroyAllDrawingTextures()
			removeCurrentWindow()
		end
	end)

-----RENDER-------------------------------------------------------

	function getElementAbsoluteOffset(element, ignore_o)

		local x,y,w,h = element[2], element[3], element[4], element[5]

		if element.parent and element.parent.overflow == 'vertical' then
			y = y + (element.parent.y_offset or 0)

			if not ignore_o then
				return x,y,w,h
			end

		elseif element.parent and element.parent.overflow == 'horizontal' then

			x = x + (element.parent.x_offset or 0)

			if not ignore_o then
				return x,y,w,h
			end

		end

		if not element.anim_fix and not disableVerticalAnim then
			y = y - 50*(1- (windowAlpha or 0) )
		end

		local _parent = element.parent
		while _parent do

			local _x,_y,_w,_h = _parent[2], _parent[3], _parent[4], _parent[5]
			x,y = x+_x,y+_y

			if _parent.parent and _parent.parent.overflow == 'vertical' then
				y = y + (_parent.parent.y_offset or 0)

				if not ignore_o then
					return x,y,w,h
				end

			elseif _parent.parent and _parent.parent.overflow == 'horizontal' then
				x = x + (_parent.parent.x_offset or 0)

				if not ignore_o then
					return x,y,w,h
				end
			end

			_parent = _parent.parent

		end

		return x,y,w,h

	end

	function getElementAbsoluteAlpha(element)

		local alpha = windowAlpha

		if element.animationAlpha then
			alpha = alpha * getAnimData(element.animationAlpha)
		end

		local _parent = element.parent
		while _parent do

			alpha = alpha * (_parent.color[4]/255)

			_parent = _parent.parent

		end

		return alpha

	end

	function pre_renderElement(k,v)

		local noDraw

		noDraw = v.noDraw or v.drawCondition
		if type(noDraw) == 'function' then
			noDraw = noDraw(v)
		end

		if not noDraw then

			local animAlpha = 1
			if v.animationAlpha then

				animAlpha = getEasingValue(
					getAnimData(v.animationAlpha),
					'InOutQuad'
				)

			end

			-- animAlpha = animAlpha * getElementAbsoluteAlpha(v)

			if not v.startcolor then
				if v.color then
					v.startcolor = v.color[4]
				else
					v.startcolor = 255
				end
			end

			v.color = v.color or {255,255,255,255}
			v.color[4] = v.startcolor * animAlpha


			if animAlpha > 0.05 and ( (v.color or ({[4]=255}))[4] > 1 or v.drawAnyway) then

				v:callHandler('gOnPreRender')

				for k,v in pairs(v.elements or {}) do
					pre_renderElement(k,v)
				end

			end
		end				

	end

	function renderElement(k,v)

		local noDraw, hovered,
			x1,y1,x2,y2

		noDraw = v.noDraw
		if type(noDraw) == 'function' then
			noDraw = noDraw(v)
		end

		x1,y1,x2,y2 = getElementAbsoluteOffset(v, true)

		if not noDraw then

			local animAlpha = getElementAbsoluteAlpha(v)
			if v.animationAlpha then

				animAlpha = animAlpha * getEasingValue(
					getAnimData(v.animationAlpha),
					'InOutQuad'
				)

			end
				
			if not v.startcolor then
				if v.color then
					v.startcolor = v.color[4]
				else
					v.startcolor = 255
				end
			end

			v.color = v.color or {255,255,255,255}
			v.color[4] = v.startcolor * animAlpha

			if animAlpha > 0.05 and ( (v.color or ({[4]=255}))[4] > 1 or v.drawAnyway) then

				v:callHandler('onPreRender')

				if v.onPostRender then
					if v.postRenderPriority then
						table.insert(postRender, { v, animAlpha, k })
					else
						table.insert(postRender, 1, { v, animAlpha, k })
					end
				end

				local animData = getAnimData(v)
				v.animData = getEasingValue(animData, 'InOutQuad')


				if drawFunctions[v[1]] then
					drawFunctions[v[1]](v, k)
				end

				if v.mtaDraw then
					hovered = mta_isMouseInPosition(x1,y1,x2,y2)
				else
					hovered = isMouseInPosition(x1,y1,x2,y2)
				end

				if hovered then

					local _, target = getAnimData(v.animId)
					if target ~= 1 then
						v:callHandler('onHover')
					end

					animate(v.animId, 1)

				else
					animate(v.animId, 0)
				end

				if hovered and not (v.noHandleHover or v.hover == false) then
					hasHoveredElement = hovered
				end
				
				v.hovered = hovered

				if hovered and v.onDragDrop and not activeDDElement then
					activeDDElement = v

					if v.onDragDropStart then
						v:onDragDropStart()
					end

				end

				if v[1] == 'list' and hovered then
					activeList = v
				end

				if v.onScroll and hovered and (v.scroll ~= false) then
					activeScrollElement = v
				end 

				v:callHandler('onRender')

				local currentSelectHover
				if activeSelect then

					local sx1,sy1,sx2,sy2 = activeSelect.selectList:abs()

					if activeSelect.mtaDraw then
						currentSelectHover = mta_isMouseInPosition(sx1,sy1,sx2,sy2)
					else
						currentSelectHover = isMouseInPosition(sx1,sy1,sx2,sy2)
					end
					

				end


				if handleClick and not currentSelectHover then
					

					inputFocused = false
					if v.onClick then

						if hovered then
							handleClick = false

							local args = { unpack(v.onClickArgs or {}) }
							table.insert(args, v)

							local posX, posY = getCursorPosition()

							posX = posX * (v.mtaDraw and real_sx or sx) - x1
							posY = posY * (v.mtaDraw and real_sy or sy) - y1

							table.insert(args, {posX, posY})
							table.insert(args, currentButtonHandle)
							local result = v.onClick( unpack(args) )

							if type(result) == 'table' and result.focusedInput then
								inputFocused = true
							end

						end

					elseif (v[1] == 'input' or v[1] == 'textarea') and not v.noEdit then

						local disabled = v.disabled
						if type(disabled) == 'function' then
							disabled = disabled()
						end
						if hovered and not disabled then
							handleClick = false
							selectedInput = v
							inputFocused = true

							v:callHandler('onFocus')

							guiSetInputMode("no_binds")
						end

					elseif v[1] == 'checkbox' then

						if hovered then

							v.checked = not v.checked
							v:callHandler('onCheck', v.checked)

						end 

					elseif v[1] == 'clickbox' then

						if hovered then

							v.selected = (v.selected or 1) + 1
							if v.selected > #(v.values or {}) then
								v.selected = 1
							end

							v:callHandler('onChange', v.values[v.selected], v.selected)

						end

					end
					if not inputFocused then

						if selectedInput then
							selectedInput:callHandler('onBlur')
						end

						selectedInput = false
					end

				end

				if v.overflow == 'vertical' then

					local width,height = x2,y2
					if not v.renderTarget then
						if not v.mtaDraw then
							width,height = px(width), px(height)
						end

						v.renderTarget = dxCreateRenderTarget(width, height, true)
					end

					dxSetBlendMode('modulate_add')
					dxSetRenderTarget(v.renderTarget, true)

					v.y_offset = getAnimData(v.ov_animId)

				elseif v.overflow == 'horizontal' then

					local width,height = x2,y2
					if not v.renderTarget then
						if not v.mtaDraw then
							width,height = px(width), px(height)
						end

						v.renderTarget = dxCreateRenderTarget(width, height, true)
					end

					dxSetBlendMode('modulate_add')
					dxSetRenderTarget(v.renderTarget, true)

					v.x_offset = getAnimData(v.ov_animId)

				end

				for k,_v in pairs(v.elements or {}) do

					if v.overflow == 'vertical' then

						local animY = getAnimData(v.ov_animId)

						if isBetween( _v[3]+animY, -_v[5], v[5] ) then
							renderElement(k,_v)
						end

					elseif v.overflow == 'horizontal' then

						local animX = getAnimData(v.ov_animId)

						if isBetween( _v[2]+animX, -_v[4], v[4] ) then
							renderElement(k,_v)
						end

					else

						renderElement(k,_v)
						
					end
				end

				if v.overflow then

					dxSetRenderTarget()
					dxSetBlendMode('blend')

					dxDrawImage(
						x1,y1,x2,y2, 
						v.renderTarget,
						0, 0, 0, tocolor(255,255,255,255*v:alpha())
					)

				end

				v:callHandler('lOnPostRender')


			end
		end

	end


	function drawWindow()

		if not currentWindowSection then return end
		if not windowModel[currentWindowSection] then return end

		local wAnim, wTarget = getAnimData('dxGui.window-alpha')

		windowAlpha = getEasingValue(wAnim, 'InOutQuad')
		if windowAlpha < 0.1 and wTarget == 0 then
			destroyAllDrawingTextures()
			
			if windowRender then
				removeEventHandler('onClientRender', root, drawWindow, true, 'low-2')
				windowRender = false
			end

			return 
		end

		if blurBackground then

			local texture = getBlurTexture(
				getScreenSource(), windowAlpha*6, windowAlpha
			)

			mta_dxDrawImage(
				0, 0, real_sx, real_sy,
				texture, 0, 0, 0,
				tocolor(255, 255, 255, 255*windowAlpha)
			)

		end

		if not hideBackground then
			mta_dxDrawRectangle(
				0, 0, real_sx, real_sy,
				tocolor(0, 0, 0, 220*windowAlpha)
			)
		end

		if windowPreRender then
			windowPreRender()
		end

		if not dragDropFlag then

			if activeDDElement and activeDDElement.onDragDropFinish then
				activeDDElement:onDragDropFinish()
			end

			activeDDElement = false

		end

		activeList = false
		activeScrollElement = false

		postRender = {}

		hasHoveredElement = false

		for k,v in pairs(windowModel[currentWindowSection]) do
			pre_renderElement(k,v)
		end

		for k,v in pairs(windowModel[currentWindowSection]) do
			renderElement(k,v)
		end


		for _, data in pairs(postRender) do
			data[1]:callHandler('onPostRender', unpack(data))
		end

		postRender = {}
		handleClick = false

	end

-----HANDLERS-------------------------------------------------------

	function onClick(button,state)

		if not windowOpened then return end
		if not isCurrentWindow() then return end

		if state == 'up' then
			dragDropFlag = false
			return
		end
		dragDropFlag = true

		guiSetInputMode("allow_binds")


		if activeSelect then

			local hoverFunc = activeSelect.mtaDraw and mta_isMouseInPosition or isMouseInPosition

			local x,y,w,h = activeSelect:abs()
			h =  h + activeSelect.selectList[5]

			if not hoverFunc(x,y,w,h) then
				animate(activeSelect.animData, 0)
				activeSelect = nil
			else
				drawFunctions.list(activeSelect.selectList, activeSelect.__data.id)
			end

		end

		currentButtonHandle = button

		-- exports.main_sounds:playSound('click')
		exports.main_sounds:playSound( 'checkbox' )
		handleClick = true


	end

	local prevMouseX, prevMouseY
	local slidePowerCoef = 1.5
	function onCursorMove(x,y)
		x,y = x * sx, y * sy

		if dragDropFlag then

			if activeDDElement then
				local posX, posY = getCursorPosition()

				local sw,sh

				if activeDDElement.mtaDraw then
					sw,sh = real_sx, real_sy
				else
					sw,sh = sx,sy
				end


				if not posX then return end

				local x,y,w,h = getElementAbsoluteOffset(activeDDElement)

				local h_posX, h_posY = posX * sw - x, posY * sh - y

				local n_posX = math.max( math.min( h_posX, activeDDElement[4] ), 0 )
				local n_posY = math.max( math.min( h_posY, activeDDElement[5] ), 0 )

				activeDDElement.onDragDrop(activeDDElement, n_posX, n_posY, posX, posY)
			end

		end
	end

	local pressed = {}

	setTimer(function()
		if not windowOpened then return end
		if pressed['backspace'] and pressed['backspace'][1] then
			if (getTickCount() - pressed['backspace'][2]) > 400 then
				deleteCurInputSymbol()
			end
		end
	end, 50, 0)

	function onCharacter(hKey)
		if not windowOpened then return end

		if not selectedInput then return end

		local element = selectedInput

		if element.type == 'number' then
			if not tonumber(hKey) then return end
		end

		if element.possibleSymbols then
			if not utf8.find( element.possibleSymbols, utf8.lower(hKey) ) then
				return
			end
		end

		if pressed['lshift'] and pressed['lshift'][1] then
			hKey = utf8.upper(hKey)
		end

		local max = element.maxSymbols or 30

		if not element.maxSymbols and element[1] == 'textarea' then
			max = 999999
		end

		if utf8.len(element[6]) < max then
			local prev = element[6]
			element[6] = element[6]..hKey

			element:callHandler('onInput', hKey, prev)

			if element._ontextareainput then
				element._ontextareainput(element, hKey)
			end

		end
	end

	function onPaste(data)
		if not windowOpened then return end

		if not selectedInput then return end

		local element = selectedInput

		if element.type == 'number' then

			for _, symbol in pairs( string.split(data) ) do
				if not tonumber(symbol) then return end
			end

		end

		if element.possibleSymbols then
			for _, symbol in pairs( string.split(data) ) do
				if not utf8.find( element.possibleSymbols, utf8.lower(symbol) ) then
					return
				end
			end
		end

		local max = element.maxSymbols or 30

		if not element.maxSymbols and element[1] == 'textarea' then
			max = 999999
		end

		if (utf8.len(element[6]) + utf8.len(data)) <= max then
			local prev = element[6]
			element[6] = element[6]..data

			if element.onInput then
				element.onInput(element, data, prev)
			end

			if element._ontextareainput then
				element._ontextareainput(element, data)
			end

		end

	end

	function element_onKey(element, key)

		local keyHandlers = element.onKey or {}
		local handlers = keyHandlers[key] or {}

		if type(handlers) == 'function' then
			handlers(element, hKey)
		elseif type(handlers) == 'table' then
			for _, handler in pairs( handlers ) do
				handler(element, hKey)
			end
		end

		for _, c_element in pairs( element.elements or {} ) do
			element_onKey( c_element, key )
		end

	end

	function onKey(key, state)
		if not windowOpened then return end

		if key == 'mouse_wheel_down' then
			if cancelScroll then return end
			if activeList then
				return scrollActiveList(-1)
			elseif activeScrollElement then
				activeScrollElement:callHandler('onScroll', 'down')
			end

			cancelEvent()
		elseif key == 'mouse_wheel_up' then
			if cancelScroll then return end
			if activeList then
				return scrollActiveList(1)
			elseif activeScrollElement then
				activeScrollElement:callHandler('onScroll', 'up')
			end

			cancelEvent()
		end

		if cancelButtons and cancelButtons[key:lower()] then
			cancelEvent()
		end

		pressed[key] = {state, getTickCount(  )}
		if not state then return end

		if key == 'backspace' then
			deleteCurInputSymbol()
		end

		if selectedInput then 

			for _, element in pairs( selectedInput.elements or {} ) do
				element_onKey(element, key)
			end

			if not (isBetween(#key, 2, 3) and key:lower():find('f')) then
				cancelEvent()
			end

		else
			for _, element in pairs( windowModel[currentWindowSection] or {} ) do
				element_onKey(element, key)
			end
		end

	end

-----MANAGER----------------------------------------------------------

	function isCurrentWindow()
		local windows_assoc = localPlayer:getData('__gui.windows') or {}

		local windows = {}

		for window, timestamp in pairs( windows_assoc ) do
			table.insert( windows, { window = window, timestamp = timestamp } )
		end

		table.sort(windows, function(a,b)
			return (tonumber(a.timestamp) or 0) > (tonumber(b.timestamp) or 0)
		end)

		return windows[1].window == getThisResource().name

	end

	function addCurrentWindow()
		local windows = localPlayer:getData('__gui.windows') or {}
		windows[ getThisResource().name ] = getTickCount()
		localPlayer:setData('__gui.windows', windows, false)
	end

	function removeCurrentWindow()
		local windows = localPlayer:getData('__gui.windows') or {}
		windows[ getThisResource().name ] = nil
		localPlayer:setData('__gui.windows', windows, false)
	end

---------------------------------------------------------------